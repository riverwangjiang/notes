## RAIL模型

尽管目前没有高性能代码的绝对定义，但却存在一个以用户为中心的性能模型，可以用作参考：RAIL模型。

**响应**

如果你的应用程序能在100毫秒内响应用户的操作，那么用户会认为该响应为即时的。这适用于可点击的元素，不适用于滚动或拖动操作。

**动画**

在60Hz的显示器上，我们希望动画和滚动时每秒有60帧，这种情况下每帧大约为16ms。在这16ms的时间内，实际上只有8-10ms来完成所有工作，其余时间则由浏览器的内部和其它差异占据。

**空闲工作**

如果你有一个耗时很久，需要持续运行的任务时，请确保把它分成很小的块，以便允许主线程对用户的输入操作做出反应。不应该出现一个任务延迟超过50ms的用户输入。

**加载**

页面加载应该在1000毫秒内完成。在移动设备上，这是一个很难达到的目标，因为它涉及到页面的互动，而不仅仅是在屏幕上渲染和滚动。

## 最大的瓶颈是加载网站所需的时间。

**具体来说就是 JavaScript 的下载、解析、编译和执行时间。除了加载更少的 JavaScript 文件或者加载的更加灵活以外，看起来没有其它办法。**

- 从根本上说，大多数 JavaScript 的性能问题，并不在于运行代码本身，而是在代码开始执行之前必须采取的一系列步骤。
- JavaScript 代码首先会被解析，也就是读取并转换成可用于编译的计算机索引的结构，然后再被编译成字节码，最后被编译成机器码，用于设备/浏览器执行。
- 另一个非常重要的方面是：JavaScript 是单线程的，并且在浏览器的主线程上运行。这意味着一次只能运行一个进程。如果你的 DevTools 性能时间线充满黄色峰值，同时 CPU 占用率达到100%，则将出现丢帧的情况。这是滚动操作常出现的，也是很讨厌的一种情况。
- 在 JavaScript 代码运行之前，需要完成所有的这些解析、编译和执行工作。**在 ChromeV8 引擎中，解析和编译占 JavaScript 执行总时间的50％左右。**

### Webpack 3 有着神奇的功能，被称作代码分割和动态导入。它不会将所有 JavaScript 模块捆绑到一个 app.js 整包中，而是使用 import( ) 语法自动分割代码并且进行异步加载。



编译代码和 polyfills 的部分。如果你正在编写现代 JavaScript 代码（ES6 +），则可以使用 Babel 将其转换为 ES5 兼容的代码。与原生 ES6+ 代码相比，编译不仅增加了文件的大小，还增加了复杂性，并且经常会出现性能下降的情况。

除此之外，你还很可能使用 babel-polyfill 软件包和 whatwg-fetch，来修复旧版本浏览器中的缺失功能。因此如果你正在编写 async/await，你还需要使用包 regenerator-runtime 的生成器来进行编译。

问题是，你为 JavaScript 软件包添加了近 100KB 的内容，这不仅是一个巨大的文件，而且预示着巨大的解析和执行花费，以便能够支持旧版本的浏览器。

一种方法是创建两个独立的 bundle，并根据实际条件来加载它们。Babel 转换编译器在 babel-preset-env 的帮助下，会使同时面临新旧两种浏览器的情况更加容易处理。

