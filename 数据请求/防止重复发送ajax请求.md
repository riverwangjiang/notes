

## 注意接口数据比较慢的时候终止数据的请求;应该是不管快慢都要来考虑这个问题


1. 连续多次请求的终止，后一次终止前一次（与setTimeout类似）；
2. 直接结束所有请求（本页面内数据切换）；
3. 请求是不是真的需要发出？

## 具体场景

有很多的应用场景都会遇到重复提交问题，比如： 
- 点击提交按钮两次。 
- 点击刷新按钮。 
- 使用浏览器后退按钮重复之前的操作，导致重复提交表单。 
- 使用浏览器历史记录重复提交表单。 
- 浏览器重复的HTTP请求。 



## 具体处理方式

1. 触发条件锁定：一次发送结束（成功或者失败返回之后，才允许下一次的请求发送）；

   ```
   A. 独占型提交只允许同时存在一次提交操作，并且直到本次提交完成才能进行下一次提交。module.submit = function() {
     if (this.promise_.state() === 'pending') {
       return
     }
     return this.promise_ = $.post('/api/save')
   }
   ```

2. 下一次请求发出的时候，终止上一次还没有返回的请求（abort）, 这里promise需要处理封装；节约时间，多提交几次，停下来总是会返回结果。

   ```
   B. 贪婪型提交无限制的提交，但是以最后一次操作为准；亦即需要尽快给出最后一次操作的反馈，而前面的操作结果并不重要。module.submit = function() {
       this.promise_.abort()
     }
     // todo
   }
   ```

3. 函数节流，大于某个时间间隔才允许提交；

   ```
   C. 节制型提交
   无论提交如何频繁，任意两次有效提交的间隔时间必定会大于或等于某一时间间隔；即以一定频率提交。
   module.submit = throttle(150, function() {
     // todo
   })
   ```
4. 像是1的操作，直接限定时间间隔，没有1好操作，各有适用场景吧；

   ```
   D. 懒惰型提交
   任意两次提交的间隔时间，必须大于一个指定时间，才会促成有效提交；即不给休息不干活。
   module.submit = debounce(150, function() {
     // todo
   })
   ```

5. 后端添加约束，相同的临近请求不做处理，防止重复提交数据

在数据库里添加唯一约束或创建唯一索引，防止出现重复数据。这是最有效的防止重复提交数据的方法。



