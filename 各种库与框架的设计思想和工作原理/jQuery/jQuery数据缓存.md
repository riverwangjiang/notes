## 内存泄露

### 什么是内存泄露？

> 内存泄露是指一块被分配的内存**既不能使用，又不能回收**，直到浏览器进程结束。在C++中，因为是手动管理内存，内存泄露是经常出现的事情。而现在流行的C#和Java等语言采用了自动垃圾回收方法管理内存，正常使用的情况下几乎不会发生内存泄露。浏览器中也是采用自动垃圾回收方法管理内存，但由于浏览器垃圾回收方法有bug，会产生内存泄露。

### 常见内存泄露的几种情况

1. 循环引用
2. Javascript闭包
3. DOM插入

>一个DOM对象被一个Javascript对象引用，与此同时又引用同一个或其它的Javascript对象，这个DOM对象可能会引发内存泄漏。**这个DOM对象的引用将不会在脚本停止的时候被垃圾回收器回收。****要想破坏循环引用，引用DOM元素的对象或DOM对象的引用需要被赋值为null**。

其实绝大部分内存泄漏都不是由Javascript引起的，浏览器的回收机制已经做的相当好了，多数的泄漏都是由于与DOM交互而产生的。

### 含有DOM对象的循环引用将导致大部分当前主流浏览器内存泄露

第一种：多个对象循环引用

var a=new Object;
var b=new Object;

a.r=b;
b.r=a;


第二种：循环引用自己

var a=new Object;
a.r=a;


循环引用很常见且大部分情况下是无害的，但当参与循环引用的对象中有DOM对象或者ActiveX对象时，循环引用将导致内存泄露。

我们把例子中的任何一个new Object替换成document.getElementById或者document.createElement就会发生内存泄露了。

### 所以这里的总结：

  ☑  JS的内存泄露，无怪乎就是**从DOM中remove了元素**，**但是依然有变量或者对象引用了该DOM对象。然后内存中无法删除。使得浏览器的内存占用居高不下。**这种内存占用，随着浏览器的刷新，会自动释放。
  ☑  而另外一种情况，就是循环引用，一个DOM对象和JS对象之间互相引用，这样造成的情况更严重一些，**即使刷新，内存也不会减少**。这就是严格意义上说的内存泄露了。

所以在平时实际应用中, 我们经常需要给元素缓存一些数据，并且这些数据往往和DOM元素紧密相关。由于DOM元素(节点)也是对象, **所以我们可以直接扩展DOM元素的属性**，但是如果给DOM元素添加自定义的属性和过多的数据可能会引起内存泄漏，所以应该要尽量避免这样做。 **因此更好的解决方法是使用一种低耦合的方式让DOM和缓存数据能够联系起来。**

所以我们必须有一种机制，避免引用数据直接依附在DOM对象上，这样尽量避免内存泄漏的产生。jQuery的缓存系统就很好的解决了这一问题。

 

## jQuery的缓存系统

### 自定义属性

一般jQuery开发，我们都喜欢便捷式的把很多属性，比如状态标志都写到dom节点中,也就是HTMLElement。

**好处：**

```
直观，便捷。
```

**坏处 ：**

```
1.循环引用
2.直接暴露数据，安全性？
3.增加一堆的自定义属性标签，对浏览器来说是没意的
4.取数据的时候要对HTML节点做操作
```

### jQuery的数据缓存接口：

```
jQuery.data( element, key, value )
.data( )
```

### $.data( element, key, value )可以对DOM元素附加任何类型的数据，但应避免循环引用而导致的内存泄漏问题。

> 这里与使用attr(),方法的区别在于自定义标签属性与数据缓存的区别，data()方法，设置，但是不显示在标签上，attr()方法是要显示在标签内的，数据安全就更差了。
>
> data() 方法向被选元素附加数据，或者从被选元素获取数据。
>

```
这里有一个坑，如果使用attr来设置data-attr属性，使用data()，方法是可以获取的，但是第二次设置的时候，使用data方法获取的是上一次的缓存值。

$(document).ready(function(){
  $("#btn1").click(function(){
    $("div").data("greeting", "Hello World");
    
  });
 $("#btn2").click(function(e){
     $('div').data('greeting', 'Hello World 2222')
})
  $("#btn3").click(function(){
    alert($("div").data("greeting"));// 没问题，操作方式比较好，保证了数据一定程度上的安全，但是不便于开发查看
  });
});
以上的操作都正确；

$(document).ready(function(){
  $("#btn1").click(function(){
    $("div").attr("data-greeting", "Hello World");
    
  });
 $("#btn2").click(function(e){
     $('div').attr('data-greeting', 'Hello World 2222')
})
  $("#btn3").click(function(){
    alert($("div").data("greeting"));// 会出问题
  });
  $("#btn4").click(function(){
    alert($("div").attr("data-greeting"));// 没问题
  });
});
这里每次都会缓存第一次data获取到的结果，虽然看到标签内的属性都没错；使用attr来获取是没有问题的；
so，这两种方式一定不要混用。
```

## 静态与实例方法的区别，jQuery.data(ele) 与 $(ele).data()

**简单的来说：**

```
1.jQuery.data()可以实现为dom元素或js对象添加缓存；
2.$("ele").data()实是对前者的扩展，其目的是可以方便的通过选择器为多个dom元素添加缓存数据；
```

```
通过.$("ele").data()原型方法会覆盖前面key相同的值。
```

### 设计的思路：（请参考右边代码）

**常规的数据缓存，我们都大多为了方便直接就绑定到了dom对应的元素上了**，最为常见的就是事件对象的回调函数了，还有一些DOM的属性。当然这也不是不可以，jQuery早期就是这么干的，**但是容易引发循环引用，也会带来一定的全局污染的问题**。那么jQuery在之后的改进就独立出了一个”数据缓存“的模块。

**其核心的关键就是：**

```
数据存放在内存中，通过一个映射关系与直接的DOM元素发生关联
```

数据缓存，jQuery现在支持两种：

```
1. dom元素，数据存储在jQuery.cache中。
2. 普通js对象，数据存储在该对象中。
```

感觉用到的情况并不多，如果后边用到，再来认真看一下。

