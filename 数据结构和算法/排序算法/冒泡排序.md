# 冒泡排序

## 原理

冒泡排序（Bubble Sort）也是一种简单直观的排序算法。**它重复地走访过要排序的数列，一次比较两个元素**，如果他们的顺序错误就把他们交换过来。

**走访数列的工作是重复地进行直到没有再需要交换，**也就是说该数列已经排序完成。

这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。

理论上只需要arr.length次

**summar:** 相邻的数据进行两两比较，小数放在前面，大数放在后面，**按照索引依次向后**，这样一趟下来，最小的数就被排在了第一位，第二趟也是如此，如此类推，直到所有的数据排序完成。

## 说明
###图片描述
 ![冒泡排序操作](imgs\冒泡排序操作.gif)
###时间与空间复杂度
1. 时间复杂度： O(n^2)    | O(n)     | O(n^2)  最好的情况应该是排好的顺序，然后循环n次后，什么也不做操作，冒泡排序可谓是最经典的排序算法了，它是基于比较的排序算法，时间复杂度为O(n^2)。
   - 其优点是实现简单，n较小时性能较好。
   - 什么时候最快（Best Cases）：当输入的数据已经是正序时。
   - 什么时候最慢（Worst Cases）：当输入的数据是反序时。
2. 空间复杂度： O(1)；// 需要交换一个变量

## 代码实现
```
function bubble_sort(arr){
    var len = arr.length;
    var time_complexity = 0;
    for(var i=0;i<len;i++){//循环次数，等于数组的长度
        for(var j=0;j<len;j++){//前后比较
            time_complexity++;//时间复杂度，无论怎样都会一次比较两个数值，所以时间复杂度都为n^2;算法的空间复杂度为1；
            if(arr[j]<arr[j-1]){//由小到大排序，第一次会把最大的排在最后，第二次会把第二大的排在倒数第二位。
                var temp = arr[j];//交换位置
                arr[j] = arr[j-1];
                arr[j-1] = temp;                
            }
        }
    }
    console.log(time_complexity);
    return arr;
}

var arr = [1,2,5,4,6,9,8,5,3,2,8];
bubble_sort(arr);
```

## 算法步骤

1）比较相邻的元素。如果第一个比第二个大，就交换他们两个。

2）对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。

3）针对所有的元素重复以上的步骤，除了最后一个。

4）持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。

